# Migrating from Svelte to HxComponents

This guide demonstrates how to convert Svelte components to the HxComponents architecture, mapping Svelte concepts to Go/HTMX patterns.

## Architecture Comparison

| Svelte Concept | HxComponents Equivalent |
|----------------|-------------------------|
| `let` (reactive variables) | Struct fields with `form` tags |
| `export let` (props) | Struct fields (passed via form data or initial state) |
| Functions | Struct methods (event handlers, helpers) |
| `$:` (reactive statements) | Struct methods called from templates |
| `on:click`, `on:input` | HTMX attributes (`hx-post`, `hx-vals`, `hxc-event`) |
| `bind:value` | Form inputs with `name` attribute + HTMX |
| `createEventDispatcher()` | Server-side event handlers (`On{EventName}`) |
| `onMount()` | `BeforeEvent()` hook with conditional logic |
| `afterUpdate()` | `AfterEvent()` hook |
| `$:` (reactive blocks) | Event handlers that compare values |
| Context API | Context values or service layer |
| Stores | Session storage or service layer |

## Getting Started: Registration & Setup

Before diving into examples, here's how to set up and register your components.

### Step 1: Project Structure

```
myproject/
├── main.go
├── go.mod
├── components/
│   └── counter/
│       ├── counter.go
│       ├── counter.templ
│       └── counter_templ.go  (generated by templ)
└── pages/
    └── index.templ
```

### Step 2: Install Dependencies

```bash
go get github.com/a-h/templ
go get github.com/go-chi/chi/v5
go get github.com/ocomsoft/HxComponents
go install github.com/a-h/templ/cmd/templ@latest
```

### Step 3: Create Your Component

See the counter example below for the component implementation.

### Step 4: Register Components and Setup Server

**main.go:**
```go
package main

import (
	"log"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/ocomsoft/HxComponents/components"
	"myproject/components/counter"
	"myproject/pages"
)

func main() {
	// Create the component registry
	registry := components.NewRegistry()

	// Register components with their URL paths
	// The string parameter becomes the URL: /component/counter
	components.Register[*counter.CounterComponent](registry, "counter")

	// You can register multiple components
	// components.Register[*todolist.TodoListComponent](registry, "todolist")
	// components.Register[*userform.UserFormComponent](registry, "userform")

	// Setup router
	router := chi.NewRouter()
	router.Use(middleware.Logger)      // Log all requests
	router.Use(middleware.Recoverer)   // Recover from panics

	// Mount component handlers (supports both GET and POST)
	router.Get("/component/*", registry.Handler)
	router.Post("/component/*", registry.Handler)

	// Serve your pages
	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		if err := pages.IndexPage().Render(r.Context(), w); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})

	// Serve static files (CSS, JS, images)
	router.Handle("/static/*", http.StripPrefix("/static/",
		http.FileServer(http.Dir("./static"))))

	log.Println("Server starting on http://localhost:8080")
	log.Fatal(http.ListenAndServe(":8080", router))
}
```

### Step 5: Create Your Index Page

**pages/index.templ:**
```templ
package pages

import "myproject/components/counter"

templ IndexPage() {
	<!DOCTYPE html>
	<html>
		<head>
			<title>My HxComponents App</title>
			<!-- Load HTMX -->
			<script src="https://unpkg.com/htmx.org@1.9.10"></script>
		</head>
		<body>
			<h1>Welcome to HxComponents</h1>

			<!-- Render component with initial state -->
			@counter.Counter(counter.CounterComponent{Count: 0})
		</body>
	</html>
}
```

### Step 6: Generate Templates and Run

```bash
# Generate templ files (run this whenever you change .templ files)
templ generate

# Run your server
go run main.go
```

Visit `http://localhost:8080` and your component will be live!

### Component Registration Options

```go
// Basic registration
components.Register[*MyComponent](registry, "mycomponent")

// The component will be available at:
// - GET  /component/mycomponent?param1=value1&param2=value2
// - POST /component/mycomponent (with form data)

// Components can have initial state when embedded in pages
comp := &counter.CounterComponent{Count: 10}
@Counter(*comp)
```

### How Components are Resolved

1. Client makes request to `/component/counter` with form data or query params
2. Registry finds the registered component by name
3. Registry creates a new instance of the component
4. Registry parses form data into component fields (using `form` tags)
5. Registry calls lifecycle hooks in order:
   - `BeforeEvent(eventName)` if implemented
   - `On{EventName}()` method if hxc-event parameter is present
   - `AfterEvent(eventName)` if implemented
   - `Process()` if implemented
6. Component is rendered using its `Render()` method
7. HTML is returned to the client
8. HTMX swaps the content based on `hx-target` and `hx-swap` attributes

## Example 1: Simple Counter

### Svelte Component

```svelte
<script>
  let count = 0;

  // Reactive statement (like computed)
  $: doubled = count * 2;

  function increment() {
    count += 1;
  }

  function decrement() {
    count -= 1;
  }
</script>

<div class="counter">
  <button on:click={decrement}>−</button>
  <span>{count}</span>
  <button on:click={increment}>+</button>
  <p>Double: {doubled}</p>
</div>
```

### HxComponents Equivalent

**counter.go:**
```go
package counter

import (
	"context"
	"io"
)

// CounterComponent - equivalent to Svelte's reactive variables
type CounterComponent struct {
	Count int `form:"count"` // let count = 0
}

// OnIncrement - equivalent to Svelte's increment function
// Called automatically when hxc-event=increment
func (c *CounterComponent) OnIncrement() error {
	c.Count++
	return nil
}

// OnDecrement - equivalent to Svelte's decrement function
// Called automatically when hxc-event=decrement
func (c *CounterComponent) OnDecrement() error {
	c.Count--
	return nil
}

// Doubled - equivalent to Svelte's $: doubled = count * 2
// Called from template as needed
func (c *CounterComponent) Doubled() int {
	return c.Count * 2
}

// Render implements templ.Component interface
func (c *CounterComponent) Render(ctx context.Context, w io.Writer) error {
	return Counter(*c).Render(ctx, w)
}
```

**counter.templ:**
```templ
package counter

import "fmt"

templ Counter(data CounterComponent) {
	<div class="counter">
		<!-- on:click={decrement} becomes hx-post with hxc-event -->
		<button
			hx-post="/component/counter"
			hx-vals={ fmt.Sprintf(`{"count": %d, "hxc-event": "decrement"}`, data.Count) }
			hx-target="closest .counter"
			hx-swap="outerHTML"
		>
			−
		</button>

		<!-- {count} becomes { fmt.Sprint(data.Count) } -->
		<span>{ fmt.Sprint(data.Count) }</span>

		<!-- on:click={increment} becomes hx-post with hxc-event -->
		<button
			hx-post="/component/counter"
			hx-vals={ fmt.Sprintf(`{"count": %d, "hxc-event": "increment"}`, data.Count) }
			hx-target="closest .counter"
			hx-swap="outerHTML"
		>
			+
		</button>

		<!-- {doubled} becomes method call { fmt.Sprint(data.Doubled()) } -->
		<p>Double: { fmt.Sprint(data.Doubled()) }</p>
	</div>
}
```

## Example 2: Todo List with Lifecycle

### Svelte Component

```svelte
<script>
  import { onMount, afterUpdate, createEventDispatcher } from 'svelte';

  export let title = 'My Todos';

  const dispatch = createEventDispatcher();

  let items = [];
  let newItemText = '';

  // Reactive statements for computed values
  $: activeCount = items.filter(i => !i.completed).length;
  $: completedCount = items.filter(i => i.completed).length;

  onMount(() => {
    console.log('TodoList mounted');
    // Could load data from API here
  });

  afterUpdate(() => {
    console.log('TodoList updated', items.length);
  });

  function addItem() {
    if (!newItemText) return;

    items = [...items, {
      id: Date.now(),
      text: newItemText,
      completed: false
    }];
    newItemText = '';
    dispatch('itemAdded');
  }

  function toggleItem(id) {
    items = items.map(item =>
      item.id === id ? { ...item, completed: !item.completed } : item
    );
    dispatch('itemToggled', { id });
  }

  function deleteItem(id) {
    items = items.filter(i => i.id !== id);
    dispatch('itemDeleted', { id });
  }

  function clearCompleted() {
    items = items.filter(i => !i.completed);
    dispatch('completedCleared');
  }
</script>

<div class="todo-list">
  <h3>{title}</h3>

  <input bind:value={newItemText} on:keydown={(e) => e.key === 'Enter' && addItem()} placeholder="Add item">
  <button on:click={addItem}>Add</button>

  <ul>
    {#each items as item (item.id)}
      <li>
        <input
          type="checkbox"
          checked={item.completed}
          on:change={() => toggleItem(item.id)}
        >
        <span class:completed={item.completed}>{item.text}</span>
        <button on:click={() => deleteItem(item.id)}>Delete</button>
      </li>
    {/each}
  </ul>

  <p>Active: {activeCount} | Completed: {completedCount}</p>
  {#if completedCount > 0}
    <button on:click={clearCompleted}>Clear Completed</button>
  {/if}
</div>

<style>
  .completed {
    text-decoration: line-through;
  }
</style>
```

### HxComponents Equivalent

**todolist.go:**
```go
package todolist

import (
	"context"
	"fmt"
	"io"
	"log/slog"
)

type TodoItem struct {
	ID        int
	Text      string
	Completed bool
}

// TodoListComponent - combines Svelte's props, reactive variables, and functions
type TodoListComponent struct {
	// Props (like export let)
	Title string `json:"-"`

	// Reactive state (like let)
	Items       []TodoItem `json:"-"`
	NewItemText string     `form:"newItemText"`
	ItemID      int        `form:"itemId"`

	// Tracking (used in lifecycle hooks)
	LastEvent  string `json:"-"`
	EventCount int    `json:"-"`
}

// BeforeEvent - equivalent to Svelte's onMount/beforeUpdate
// Called before any event handler
func (t *TodoListComponent) BeforeEvent(ctx context.Context, eventName string) error {
	slog.Info("TodoList event starting", "event", eventName)

	// This is like onMount() or beforeUpdate()
	// You could validate authentication here
	// You could load data from database here

	return nil
}

// AfterEvent - equivalent to Svelte's afterUpdate
// Called after successful event handler
func (t *TodoListComponent) AfterEvent(ctx context.Context, eventName string) error {
	slog.Info("TodoList event completed", "event", eventName, "itemCount", len(t.Items))

	t.LastEvent = eventName
	t.EventCount++

	// Equivalent to Svelte's dispatch()
	// You could trigger webhooks, send notifications, etc.

	return nil
}

// OnAddItem - equivalent to Svelte's addItem function
// Automatically called when hxc-event=addItem
func (t *TodoListComponent) OnAddItem() error {
	if t.NewItemText == "" {
		return fmt.Errorf("item text cannot be empty")
	}

	// Generate new ID
	newID := len(t.Items) + 1
	for _, item := range t.Items {
		if item.ID >= newID {
			newID = item.ID + 1
		}
	}

	// Add the new item (like items = [...items, newItem])
	t.Items = append(t.Items, TodoItem{
		ID:        newID,
		Text:      t.NewItemText,
		Completed: false,
	})

	// Clear the input (like newItemText = '')
	t.NewItemText = ""

	slog.Info("Added todo item", "id", newID)
	return nil
}

// OnToggleItem - equivalent to Svelte's toggleItem function
func (t *TodoListComponent) OnToggleItem() error {
	for i := range t.Items {
		if t.Items[i].ID == t.ItemID {
			t.Items[i].Completed = !t.Items[i].Completed
			slog.Info("Toggled todo item", "id", t.ItemID, "completed", t.Items[i].Completed)
			return nil
		}
	}
	return fmt.Errorf("item with ID %d not found", t.ItemID)
}

// OnDeleteItem - equivalent to Svelte's deleteItem function
func (t *TodoListComponent) OnDeleteItem() error {
	for i, item := range t.Items {
		if item.ID == t.ItemID {
			t.Items = append(t.Items[:i], t.Items[i+1:]...)
			slog.Info("Deleted todo item", "id", t.ItemID)
			return nil
		}
	}
	return fmt.Errorf("item with ID %d not found", t.ItemID)
}

// OnClearCompleted - equivalent to Svelte's clearCompleted function
func (t *TodoListComponent) OnClearCompleted() error {
	remaining := []TodoItem{}
	removedCount := 0

	for _, item := range t.Items {
		if !item.Completed {
			remaining = append(remaining, item)
		} else {
			removedCount++
		}
	}

	t.Items = remaining
	slog.Info("Cleared completed items", "count", removedCount)
	return nil
}

// GetActiveCount - equivalent to Svelte's $: activeCount = ...
func (t *TodoListComponent) GetActiveCount() int {
	count := 0
	for _, item := range t.Items {
		if !item.Completed {
			count++
		}
	}
	return count
}

// GetCompletedCount - equivalent to Svelte's $: completedCount = ...
func (t *TodoListComponent) GetCompletedCount() int {
	count := 0
	for _, item := range t.Items {
		if item.Completed {
			count++
		}
	}
	return count
}

// Render implements templ.Component interface
func (t *TodoListComponent) Render(ctx context.Context, w io.Writer) error {
	return TodoList(*t).Render(ctx, w)
}
```

**todolist.templ:**
```templ
package todolist

import "fmt"

templ TodoList(data TodoListComponent) {
	<div class="todo-list">
		<!-- {title} becomes { data.Title } -->
		<h3>{ data.Title }</h3>

		<!-- bind:value becomes name attribute + hx-include -->
		<input
			type="text"
			name="newItemText"
			value={ data.NewItemText }
			placeholder="Add item"
		/>

		<!-- on:click becomes hx-post with hxc-event -->
		<button
			hx-post="/component/todolist"
			hx-include="[name='newItemText']"
			hx-vals='{"hxc-event": "addItem"}'
			hx-target="closest .todo-list"
			hx-swap="outerHTML"
		>
			Add
		</button>

		<ul>
			<!-- {#each items as item} becomes Go for loop -->
			for _, item := range data.Items {
				<li>
					<!-- checked and on:change become hx-post -->
					<input
						type="checkbox"
						checked?={ item.Completed }
						hx-post="/component/todolist"
						hx-vals={ fmt.Sprintf(`{"itemId": %d, "hxc-event": "toggleItem"}`, item.ID) }
						hx-target="closest .todo-list"
						hx-swap="outerHTML"
					/>

					<!-- class:completed becomes style attribute with conditional -->
					<span style={ fmt.Sprintf("%s",
						func() string {
							if item.Completed {
								return "text-decoration: line-through;"
							}
							return ""
						}()) }>
						{ item.Text }
					</span>

					<button
						hx-post="/component/todolist"
						hx-vals={ fmt.Sprintf(`{"itemId": %d, "hxc-event": "deleteItem"}`, item.ID) }
						hx-target="closest .todo-list"
						hx-swap="outerHTML"
					>
						Delete
					</button>
				</li>
			}
		</ul>

		<!-- {activeCount} becomes method call { fmt.Sprint(data.GetActiveCount()) } -->
		<p>
			Active: { fmt.Sprint(data.GetActiveCount()) } |
			Completed: { fmt.Sprint(data.GetCompletedCount()) }
		</p>

		<!-- {#if} becomes Go if statement -->
		if data.GetCompletedCount() > 0 {
			<button
				hx-post="/component/todolist"
				hx-vals='{"hxc-event": "clearCompleted"}'
				hx-target="closest .todo-list"
				hx-swap="outerHTML"
			>
				Clear Completed
			</button>
		}
	</div>
}
```

## Example 3: Form with Reactive Statements

### Svelte Component

```svelte
<script>
  let email = '';
  let password = '';
  let emailError = '';
  let passwordError = '';

  // Reactive statements for validation (like watchers)
  $: {
    if (!email) {
      emailError = 'Email is required';
    } else if (!email.includes('@')) {
      emailError = 'Invalid email';
    } else {
      emailError = '';
    }
  }

  $: {
    if (!password) {
      passwordError = 'Password is required';
    } else if (password.length < 8) {
      passwordError = 'Password must be 8+ characters';
    } else {
      passwordError = '';
    }
  }

  // Reactive computed value
  $: isValid = !emailError && !passwordError && email && password;

  function submit() {
    if (isValid) {
      console.log('Submit', { email, password });
    }
  }
</script>

<div class="user-form">
  <input bind:value={email} placeholder="Email">
  {#if emailError}
    <p class="error">{emailError}</p>
  {/if}

  <input bind:value={password} type="password" placeholder="Password">
  {#if passwordError}
    <p class="error">{passwordError}</p>
  {/if}

  <button on:click={submit} disabled={!isValid}>Submit</button>
</div>
```

### HxComponents Equivalent

**userform.go:**
```go
package userform

import (
	"context"
	"fmt"
	"io"
	"strings"
)

type UserFormComponent struct {
	Email         string `form:"email"`
	Password      string `form:"password"`
	EmailError    string `json:"-"`
	PasswordError string `json:"-"`
}

// BeforeEvent - equivalent to Svelte's $: reactive blocks
// This replaces reactive statements by running before every event
func (f *UserFormComponent) BeforeEvent(ctx context.Context, eventName string) error {
	f.validateEmail()
	f.validatePassword()
	return nil
}

// OnSubmit - equivalent to Svelte's submit function
func (f *UserFormComponent) OnSubmit() error {
	// Validation already done in BeforeEvent
	if !f.IsValid() {
		return fmt.Errorf("form is not valid")
	}

	// Process the submission
	// This is where you'd save to database, send email, etc.

	return nil
}

// OnValidate - trigger validation manually (like Svelte input events)
func (f *UserFormComponent) OnValidate() error {
	// Validation happens in BeforeEvent
	// This event just triggers a re-render
	return nil
}

// validateEmail - equivalent to Svelte's $: reactive block for email
func (f *UserFormComponent) validateEmail() {
	if f.Email == "" {
		f.EmailError = "Email is required"
	} else if !strings.Contains(f.Email, "@") {
		f.EmailError = "Invalid email"
	} else {
		f.EmailError = ""
	}
}

// validatePassword - equivalent to Svelte's $: reactive block for password
func (f *UserFormComponent) validatePassword() {
	if f.Password == "" {
		f.PasswordError = "Password is required"
	} else if len(f.Password) < 8 {
		f.PasswordError = "Password must be 8+ characters"
	} else {
		f.PasswordError = ""
	}
}

// IsValid - equivalent to Svelte's $: isValid = ...
func (f *UserFormComponent) IsValid() bool {
	return f.EmailError == "" && f.PasswordError == "" &&
		f.Email != "" && f.Password != ""
}

func (f *UserFormComponent) Render(ctx context.Context, w io.Writer) error {
	return UserForm(*f).Render(ctx, w)
}
```

**userform.templ:**
```templ
package userform

templ UserForm(data UserFormComponent) {
	<div class="user-form">
		<!-- bind:value with validation on change -->
		<input
			type="email"
			name="email"
			value={ data.Email }
			placeholder="Email"
			hx-post="/component/userform"
			hx-trigger="change"
			hx-vals='{"hxc-event": "validate"}'
			hx-include="closest .user-form input"
			hx-target="closest .user-form"
			hx-swap="outerHTML"
		/>

		<!-- {#if emailError} becomes if statement -->
		if data.EmailError != "" {
			<p class="error">{ data.EmailError }</p>
		}

		<input
			type="password"
			name="password"
			value={ data.Password }
			placeholder="Password"
			hx-post="/component/userform"
			hx-trigger="change"
			hx-vals='{"hxc-event": "validate"}'
			hx-include="closest .user-form input"
			hx-target="closest .user-form"
			hx-swap="outerHTML"
		/>

		if data.PasswordError != "" {
			<p class="error">{ data.PasswordError }</p>
		}

		<!-- disabled={!isValid} becomes disabled? -->
		<button
			disabled?={ !data.IsValid() }
			hx-post="/component/userform"
			hx-vals='{"hxc-event": "submit"}'
			hx-include="closest .user-form input"
			hx-target="closest .user-form"
			hx-swap="outerHTML"
		>
			Submit
		</button>
	</div>
}
```

## Key Migration Patterns

### 1. Reactive Variables

**Svelte:**
```svelte
<script>
  let count = 0;
  count += 1; // Triggers reactivity
</script>
```

**HxComponents:**
```go
type Component struct {
	Count int `form:"count"`
}

func (c *Component) OnIncrement() error {
	c.Count++
	return nil
}
```

### 2. Props (export let)

**Svelte:**
```svelte
<script>
  export let title;
  export let count = 0; // With default
</script>

<h1>{title}: {count}</h1>
```

**HxComponents:**
```go
type Component struct {
	Title string `json:"-"`
	Count int    `json:"-"` // Default set in initialization
}
```

```templ
templ Component(data Component) {
	<h1>{ data.Title }: { fmt.Sprint(data.Count) }</h1>
}
```

### 3. Reactive Statements ($:)

**Svelte:**
```svelte
<script>
  let firstName = 'John';
  let lastName = 'Doe';
  $: fullName = `${firstName} ${lastName}`;
</script>
```

**HxComponents:**
```go
type Component struct {
	FirstName string `form:"firstName"`
	LastName  string `form:"lastName"`
}

func (c *Component) FullName() string {
	return c.FirstName + " " + c.LastName
}
```

```templ
<p>{ data.FullName() }</p>
```

### 4. Event Handlers

**Svelte:**
```svelte
<button on:click={handleClick}>Click</button>
<button on:click={() => count++}>Increment</button>
```

**HxComponents:**
```templ
<button
	hx-post="/component/mycomponent"
	hx-vals='{"hxc-event": "handleClick"}'
	hx-target="closest .container"
	hx-swap="outerHTML"
>
	Click
</button>
```

```go
func (c *Component) OnHandleClick() error {
	c.Count++
	return nil
}
```

### 5. Two-Way Binding (bind:)

**Svelte:**
```svelte
<input bind:value={username}>
<input type="checkbox" bind:checked={accepted}>
```

**HxComponents:**
```templ
<input
	name="username"
	value={ data.Username }
	hx-post="/component/form"
	hx-trigger="change"
	hx-include="closest form"
	hx-target="closest form"
	hx-swap="outerHTML"
/>

<input
	type="checkbox"
	name="accepted"
	checked?={ data.Accepted }
	hx-post="/component/form"
	hx-trigger="change"
	hx-include="closest form"
	hx-target="closest form"
	hx-swap="outerHTML"
/>
```

### 6. Conditional Rendering

**Svelte:**
```svelte
{#if show}
  <p>Visible</p>
{:else}
  <p>Hidden</p>
{/if}
```

**HxComponents:**
```templ
if data.Show {
	<p>Visible</p>
} else {
	<p>Hidden</p>
}
```

### 7. List Rendering

**Svelte:**
```svelte
{#each items as item (item.id)}
  <li>{item.name}</li>
{/each}
```

**HxComponents:**
```templ
for _, item := range data.Items {
	<li>{ item.Name }</li>
}
```

### 8. Event Dispatching

**Svelte:**
```svelte
<script>
  import { createEventDispatcher } from 'svelte';
  const dispatch = createEventDispatcher();

  function handleClick() {
    dispatch('message', { text: 'Hello' });
  }
</script>
```

**HxComponents:**
```go
// Event dispatching is replaced by lifecycle hooks
func (c *Component) OnClick() error {
	// Handle the event
	return nil
}

func (c *Component) AfterEvent(ctx context.Context, eventName string) error {
	// This is where you'd trigger side effects
	// Like calling webhooks, sending notifications, etc.
	log.Println("Event dispatched:", eventName)
	return nil
}
```

### 9. Lifecycle Hooks

**Svelte:**
```svelte
<script>
  import { onMount, beforeUpdate, afterUpdate, onDestroy } from 'svelte';

  onMount(() => {
    console.log('Component mounted');
  });

  afterUpdate(() => {
    console.log('Component updated');
  });

  onDestroy(() => {
    console.log('Component destroyed');
  });
</script>
```

**HxComponents:**
```go
func (c *Component) BeforeEvent(ctx context.Context, eventName string) error {
	// Like onMount or beforeUpdate
	log.Println("Event starting:", eventName)
	return nil
}

func (c *Component) AfterEvent(ctx context.Context, eventName string) error {
	// Like afterUpdate
	log.Println("Event completed:", eventName)
	return nil
}

// No direct equivalent to onDestroy since components are stateless
// Use context cancellation or cleanup in AfterEvent if needed
```

### 10. Stores

**Svelte:**
```svelte
<script>
  import { writable } from 'svelte/store';

  const count = writable(0);

  function increment() {
    count.update(n => n + 1);
  }
</script>

<p>{$count}</p>
```

**HxComponents:**
```go
// Use session storage or a service layer for shared state
type SessionStore struct {
	Count int
}

func (c *Component) BeforeEvent(ctx context.Context, eventName string) error {
	// Load from session or database
	session := getSession()
	c.Count = session.Count
	return nil
}

func (c *Component) AfterEvent(ctx context.Context, eventName string) error {
	// Save to session or database
	saveToSession(c.Count)
	return nil
}
```

### 11. Class Directives

**Svelte:**
```svelte
<div class:active={isActive}>Content</div>
<div class:active class:disabled={!enabled}>Content</div>
```

**HxComponents:**
```templ
<div class={ fmt.Sprintf("%s", func() string {
	if data.IsActive {
		return "active"
	}
	return ""
}()) }>
	Content
</div>

<!-- Or use style attribute -->
<div style={ fmt.Sprintf("%s", func() string {
	if data.IsActive {
		return "background-color: blue;"
	}
	return ""
}()) }>
	Content
</div>
```

### 12. Context API

**Svelte:**
```svelte
<!-- Parent.svelte -->
<script>
  import { setContext } from 'svelte';
  setContext('user', { name: 'John' });
</script>

<!-- Child.svelte -->
<script>
  import { getContext } from 'svelte';
  const user = getContext('user');
</script>
```

**HxComponents:**
```go
// Use context.Context for passing data
func (c *Component) BeforeEvent(ctx context.Context, eventName string) error {
	// Get user from session, database, or context
	user := getUserFromContext(c.ctx)
	c.CurrentUser = user
	return nil
}
```

## Benefits of HxComponents over Svelte

1. **Type Safety**: Go's type system catches errors at compile time
2. **Simpler Deployment**: Single binary, no build step needed
3. **Performance**: Server-side rendering with minimal JavaScript
4. **SEO Friendly**: All content rendered on server
5. **Better Security**: Business logic stays on server
6. **No Magic**: Explicit control flow without compiler magic
7. **Familiar for Backend Devs**: Uses standard Go patterns

## When to Use Each

**Use Svelte when:**
- You need rich client-side interactivity
- You want the smallest bundle size possible
- You want offline-first capabilities
- You prefer reactive programming model
- Complex client-side state management is required

**Use HxComponents when:**
- You want simpler architecture
- SEO is important
- You prefer type safety and compile-time errors
- You want to avoid build tooling
- Server-side rendering fits your use case
- You're already working in Go
- You want to minimize JavaScript
