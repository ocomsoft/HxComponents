# Getting Started with HxComponents

This guide walks you through setting up and registering your first HxComponents application.

## Project Structure

```
myproject/
├── main.go
├── go.mod
├── components/
│   └── counter/
│       ├── counter.go
│       ├── counter.templ
│       └── counter_templ.go  (generated by templ)
└── pages/
    └── index.templ
```

## Installation

### Step 1: Install Dependencies

```bash
go get github.com/a-h/templ
go get github.com/go-chi/chi/v5
go get github.com/ocomsoft/HxComponents
go install github.com/a-h/templ/cmd/templ@latest
```

### Step 2: Create Your Component

See the migration guides for examples of creating components from React, Vue, or Svelte.

### Step 3: Register Components and Setup Server

**main.go:**
```go
package main

import (
	"log"
	"net/http"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"
	"github.com/ocomsoft/HxComponents/components"
	"myproject/components/counter"
	"myproject/pages"
)

func main() {
	// Create the component registry
	registry := components.NewRegistry()

	// Register components with their URL paths
	// The string parameter becomes the URL: /component/counter
	components.Register[*counter.CounterComponent](registry, "counter")

	// You can register multiple components
	// components.Register[*todolist.TodoListComponent](registry, "todolist")
	// components.Register[*userform.UserFormComponent](registry, "userform")

	// Setup router
	router := chi.NewRouter()
	router.Use(middleware.Logger)      // Log all requests
	router.Use(middleware.Recoverer)   // Recover from panics

	// Mount component handlers (supports both GET and POST)
	router.Get("/component/*", registry.Handler)
	router.Post("/component/*", registry.Handler)

	// Serve your pages
	router.Get("/", func(w http.ResponseWriter, r *http.Request) {
		if err := pages.IndexPage().Render(r.Context(), w); err != nil {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		}
	})

	// Serve static files (CSS, JS, images)
	router.Handle("/static/*", http.StripPrefix("/static/",
		http.FileServer(http.Dir("./static"))))

	log.Println("Server starting on http://localhost:8080")
	log.Fatal(http.ListenAndServe(":8080", router))
}
```

### Step 4: Create Your Index Page

**pages/index.templ:**
```templ
package pages

import "myproject/components/counter"

templ IndexPage() {
	<!DOCTYPE html>
	<html>
		<head>
			<title>My HxComponents App</title>
			<!-- Load HTMX -->
			<script src="https://unpkg.com/htmx.org@1.9.10"></script>
		</head>
		<body>
			<h1>Welcome to HxComponents</h1>

			<!-- Render component with initial state -->
			@counter.Counter(counter.CounterComponent{Count: 0})
		</body>
	</html>
}
```

### Step 5: Generate Templates and Run

```bash
# Generate templ files (run this whenever you change .templ files)
templ generate

# Run your server
go run main.go
```

Visit `http://localhost:8080` and your component will be live!

## Component Registration Options

```go
// Basic registration
components.Register[*MyComponent](registry, "mycomponent")

// The component will be available at:
// - GET  /component/mycomponent?param1=value1&param2=value2
// - POST /component/mycomponent (with form data)

// Components can have initial state when embedded in pages
comp := &counter.CounterComponent{Count: 10}
@Counter(*comp)
```

## How Components are Resolved

1. Client makes request to `/component/counter` with form data or query params
2. Registry finds the registered component by name
3. Registry creates a new instance of the component
4. Registry parses form data into component fields (using `form` tags)
5. Registry calls lifecycle hooks in order:
   - `BeforeEvent(ctx, eventName)` if implemented
   - `On{EventName}()` method if hxc-event parameter is present
   - `AfterEvent(ctx, eventName)` if implemented
   - `Process(ctx)` if implemented
6. Component is rendered using its `Render()` method
7. HTML is returned to the client
8. HTMX swaps the content based on `hx-target` and `hx-swap` attributes

## Component Lifecycle

```
Request → Parse Form Data → BeforeEvent → On{EventName} → AfterEvent → Process → Render → Response
```

### Lifecycle Hooks

**BeforeEvent(ctx context.Context, eventName string) error**
- Called before any event handler
- Use for authentication, loading data from database/session
- Return error to abort the request
- Context provides request-scoped values and cancellation

**On{EventName}() error**
- Event handler method (e.g., `OnSubmit`, `OnAddItem`)
- Called when `hxc-event` parameter matches the event name
- Return error to indicate failure

**AfterEvent(ctx context.Context, eventName string) error**
- Called after successful event handler
- Use for saving data, triggering webhooks, notifications
- Return error to indicate failure
- Context provides request-scoped values and cancellation

**Process(ctx context.Context) error**
- Called after all events, before rendering
- Use for final data transformations
- Return error to indicate failure
- Context provides request-scoped values and cancellation

## Development Workflow

1. **Create component struct** with `form` tags for inputs
2. **Add event handlers** as `On{EventName}() error` methods
3. **Create templ template** for rendering
4. **Implement lifecycle hooks** if needed (BeforeEvent, AfterEvent)
5. **Register component** in main.go
6. **Run `templ generate`** to compile templates
7. **Test** your component

## Next Steps

- See the migration guides for specific framework examples (React, Vue, Svelte)
- Read [ADVANCED_PATTERNS.md](ADVANCED_PATTERNS.md) for HTMX patterns, animations, and optimizations
- Read [TESTING.md](TESTING.md) for testing strategies
- Read [COMMON_GOTCHAS.md](COMMON_GOTCHAS.md) for troubleshooting common issues
- Read [COMPONENT_COMPOSITION.md](COMPONENT_COMPOSITION.md) for building complex UIs
